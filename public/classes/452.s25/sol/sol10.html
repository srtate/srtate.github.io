<!DOCTYPE html>
<html lang="en">

    <head>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="Stephen R. Tate">

    <title>CSC 452/652/752 - Spring 2025 - Assignments</title>

    <!-- Bootstrap CSS CDN -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.0/css/bootstrap.min.css" integrity="sha384-9gVQ4dYFwwWSjIDZnLEWnxCjeSWFphJiwGPXr1jddIhOegiu1FwO5qRGvFXOdJZ4" crossorigin="anonymous">

    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
    <![endif]-->

    <!-- Custom styles for this template -->
    <link href="../../css/canvas_srtate.css" rel="stylesheet">


    <script type="text/x-mathjax-config"> 
       MathJax.Hub.Config({ 
        "HTML-CSS": { scale: 94, linebreaks: { automatic: true } }
		});
    </script>

  </head>


  <body>

    <!-- Page Content -->
    <div class="container">

    <p>Reminder about <a href="../browser.html">browser check</a> – you should see “OK” in script here: <span class="math inline">\({\mathcal O}{\mathcal K}\)</span></p>
      
   
        <ol type="1">
<li><p>(Textbook, Exercise 7.18) [<em>How to “grade” your work (10 points): You have to show that any non-trivial language in <span class="math inline">\(P\)</span> is <span class="math inline">\(NP\)</span>-complete, so it should start like the proof below (giving a name to a non-trivial language in <span class="math inline">\(P\)</span>: 2 points for this). Then make sure that your proof specifically addresses the two parts necessary for <span class="math inline">\(NP\)</span>-completeness: that the language is in <span class="math inline">\(NP\)</span> (this is easy but must be included: 2 points) and that all languages in <span class="math inline">\(NP\)</span> are reducible to this language: give a reduction (2 points), justify that it works (2 points), and that it’s polynomial time (1 points). Then make sure you give a conclusion (1 point). </em>]</p>
<p>Let <span class="math inline">\(B\in P\)</span> be any non-trivial language in <span class="math inline">\(P\)</span> (non-trivial means <span class="math inline">\(B\neq\emptyset\)</span> and <span class="math inline">\(B\neq \Sigma^*\)</span>). We use the definition of <span class="math inline">\(NP\)</span>-completeness (Definition 7.34 in the textbook) to show that <span class="math inline">\(B\)</span> is <span class="math inline">\(NP\)</span>-complete.</p>
<p>First, since <span class="math inline">\(P\subseteq NP\)</span> we know that <span class="math inline">\(B\in NP\)</span>, satisfying the first part of Definition 7.34.</p>
<p>For the second part of the definition, let <span class="math inline">\(A\)</span> be any language in <span class="math inline">\(NP\)</span>. Since we are assuming <span class="math inline">\(P=NP\)</span>, we also have <span class="math inline">\(A\in P\)</span>, so there’s a polynomial time decision algorithm for <span class="math inline">\(A\)</span>, say <span class="math inline">\(M_A\)</span>. Since <span class="math inline">\(B\)</span> is non-trivial, there is an <span class="math inline">\(x\in B\)</span> and <span class="math inline">\(y\not\in B\)</span>. The reduction <span class="math inline">\(f\)</span> for <span class="math inline">\(A\leq_{P} B\)</span> is constructed as follows: Given input <span class="math inline">\(w\)</span> for problem <span class="math inline">\(A\)</span>, run <span class="math inline">\(M_A\)</span> to determine if <span class="math inline">\(w\in A\)</span> or not, then <span class="math inline">\(f\)</span> outputs a value as defined below:</p>
<p><span class="math display">\[
   f(w) = \left\{ \begin{array}{ll}
   x &amp; \text{if } w\in A;\\
   y &amp; \text{otherwise.}
   \end{array} \right.
\]</span></p>
<p>It follows that <span class="math inline">\(w\in A\)</span> if and only if <span class="math inline">\(f(w)\in B\)</span>, and <span class="math inline">\(f\)</span> runs in polynomial time, so <span class="math inline">\(A\leq_{P} B\)</span>. This completes the proof of the second part of Definition 7.34, so we conclude that <span class="math inline">\(B\)</span> is <span class="math inline">\(NP\)</span>-complete.</p>
<p><span class="math inline">\(B\)</span> was arbitrary, so the conclusion is that if <span class="math inline">\(P=NP\)</span> then every non-trivial language in <span class="math inline">\(P\)</span> is <span class="math inline">\(NP\)</span>-complete.</p></li>
<li><p>(Textbook, Exercise 7.21)</p>
<ol type="a">
<li><p>[<em>How to “grade” your work (8 points): For this part, you should give a clear and precise algorithm to decide <span class="math inline">\(\textit{SPATH}\)</span> in polynomial time. It doesn’t <strong>have</strong> to be the step-by-step Turing machine definition as given below, but it needs to be precise. You will almost certainly use breadth-first search (BFS) in any correct algorithm, so be clear that this is what you’re doing. Giving a precise algorithm description is worth 6 points, and justifying that it is polynomial time is worth 2 points. </em>]</p>
<p>Show <span class="math inline">\(\textit{SPATH}\in P\)</span>, where</p>
<p><span class="math display">\[ \textit{SPATH} = \{ \langle G,a,b,k\rangle\,|\, G
\text{ contains a simple path of length at most $k$ from
$a$ to $b$} \} \]</span></p>
<p>Breadth-first search finds shortest paths in polynomial time, and since a graph <span class="math inline">\(G\)</span> has a simple path from <span class="math inline">\(a\)</span> to <span class="math inline">\(b\)</span> of length at most <span class="math inline">\(k\)</span> if and only if the shortest path from <span class="math inline">\(a\)</span> to <span class="math inline">\(b\)</span> has length at most <span class="math inline">\(k\)</span>, then BFS can be used to directly decide <span class="math inline">\(\textit{SPATH}\)</span>. In particular:</p>
<p><span class="math inline">\(M=\)</span> "On input <span class="math inline">\(\langle G,a,b,k\rangle\)</span>:</p>
<ol type="1">
<li><p>Run BFS on graph <span class="math inline">\(G\)</span>, starting from vertex <span class="math inline">\(a\)</span>.</p></li>
<li><p>If BFS finds a path of length <span class="math inline">\(\leq k\)</span> to <span class="math inline">\(b\)</span> then <em>accept</em>; else <em>reject</em>."</p></li>
</ol>
<p><span class="math inline">\(M\)</span> clearly decides <span class="math inline">\(\textit{SPATH}\)</span> and runs in polynomial time since BFS does. Therefore <span class="math inline">\(\textit{SPATH}\in P\)</span>.</p></li>
<li><p>[<em>How to “grade” your work (15 points): A proof of NP-completeness must have four parts. First, you must show that <span class="math inline">\(LPATH\in NP\)</span> (4 points – 2 points for defining a certificate, and 2 points for explaining that it is verified in polynomial time). Next you must define a reduction function (in the right direction, so it must take a HAMPATH input and produce an LPATH input if you use HAMPATH as the “known NP-complete problem”) and justify that it is polynomial time (4 points – note that the justification can almost always be that it’s obviously polynomial time). Then you must show <strong>both</strong> directions of the “if and only if” part of the reduction definition (3 points each). Then use 1 points for tying everything together in the proof, concluding that LPATH is NP-complete. </em>]</p>
<p>Show <span class="math inline">\(\textit{LPATH}\)</span> is <span class="math inline">\(NP\)</span>-complete, where</p>
<p><span class="math display">\[ \textit{LPATH} = \{ \langle G,a,b,k\rangle\,|\, G
\text{ contains a simple path of length at least $k$ from
$a$ to $b$} \}\ . \]</span></p>
<p>To show that <span class="math inline">\(LPATH\)</span> is <span class="math inline">\(NP\)</span>-complete, we will show that it is in <span class="math inline">\(NP\)</span> and that <span class="math inline">\(HAMPATH\leq_p LPATH\)</span>.</p>
<p>To show that <span class="math inline">\(LPATH\)</span> is in <span class="math inline">\(NP\)</span>, we define the certificate for any <span class="math inline">\(\langle G,a,b,k\rangle\in LPATH\)</span> to be a simple path from <span class="math inline">\(a\)</span> to <span class="math inline">\(b\)</span> of length at least <span class="math inline">\(k\)</span>. The verifier can easily check that the provided certificate is a valid simple path in polynomial time, and that the length is at least <span class="math inline">\(k\)</span>. This easily-verified certificate exists if and only if <span class="math inline">\(\langle G,a,b,k\rangle\in LPATH\)</span>, so it follows that <span class="math inline">\(LPATH\in NP\)</span>.</p>
<p>We define a polynomial-time reduction from <span class="math inline">\(HAMPATH\)</span> to <span class="math inline">\(LPATH\)</span>. Given an input <span class="math inline">\(\langle G,s,t\rangle\)</span> for <span class="math inline">\(HAMPATH\)</span> the reduction first determines the number of vertices in <span class="math inline">\(G\)</span>, say <span class="math inline">\(n\)</span>, and then outputs <span class="math inline">\(\langle G,s,t,n-1\rangle\)</span> as an input instance for <span class="math inline">\(LPATH\)</span>. This is a very simple computation that can clearly be done in polynomial time. We next show that it’s a valid reduction.</p>
<p>Assume that <span class="math inline">\(\langle G,s,t\rangle\in HAMPATH\)</span>. A Hamiltonian path is, by definition, a simple path that goes through all <span class="math inline">\(n\)</span> vertices of the graph, starting at <span class="math inline">\(s\)</span> and ending at <span class="math inline">\(t\)</span>. A path with <span class="math inline">\(n\)</span> vertices has <span class="math inline">\(n-1\)</span> edges, so this is a simple path of length <span class="math inline">\(n-1\)</span>. Therefore, <span class="math inline">\(\langle G,s,t,n-1\rangle\in LPATH\)</span>.</p>
<p>Next, assume that <span class="math inline">\(\langle G,s,t,n-1\rangle\in LPATH\)</span>. Then there is a simple path of length at least <span class="math inline">\(n-1\)</span> from <span class="math inline">\(s\)</span> to <span class="math inline">\(t\)</span> in <span class="math inline">\(G\)</span>. Any path of length <span class="math inline">\(n-1\)</span> must have <span class="math inline">\(n\)</span> vertices, and since it’s a simple path each vertex can only appear once in the path. That means we must have <span class="math inline">\(n\)</span> <em>distinct</em> vertices, which means all of the vertices in the graph. Therefore, this simple path is a Hamiltonian path, and <span class="math inline">\(\langle G,s,t\rangle\in HAMPATH\)</span>.</p>
<p>Therefore we have shown a polynomial time computation of <span class="math inline">\(\langle G,s,t,n-1\rangle\)</span> from <span class="math inline">\(\langle G,s,t\rangle\)</span> such that <span class="math inline">\(\langle G,s,t\rangle\in HAMPATH\)</span> if and only if <span class="math inline">\(\langle G,s,t,n-1\rangle\in LPATH\)</span>. This is a polynomial time reduction, so <span class="math inline">\(HAMPATH\leq_p LPATH\)</span>. Finally, since <span class="math inline">\(HAMPATH\)</span> is NP-complete (from Theorem 7.46) and we also showed that <span class="math inline">\(LPATH\in NP\)</span>, it follows by Theorem 7.36 that <span class="math inline">\(LPATH\)</span> is <span class="math inline">\(NP\)</span>-complete.</p></li>
</ol></li>
</ol>
<p> </p>

    </div>

        <!-- jQuery CDN - Slim version (=without AJAX) -->
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <!-- Bootstrap JS -->
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.0/js/bootstrap.min.js" integrity="sha384-uefMccjFJAIv6A+rW+L4AHf99KvxDjWSu1z9VI8SKNVmz4sk7buKt/6v9KI65qnm" crossorigin="anonymous"></script>



  </body>

</html>
