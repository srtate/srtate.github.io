<!DOCTYPE html>
<html lang="en">

    <head>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="Stephen R. Tate">

    <title>CSC 454/654 - Spring 2020 - Assignment 5 - Due April 29, 2020</title>

    <!-- Bootstrap CSS CDN -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.0/css/bootstrap.min.css" integrity="sha384-9gVQ4dYFwwWSjIDZnLEWnxCjeSWFphJiwGPXr1jddIhOegiu1FwO5qRGvFXOdJZ4" crossorigin="anonymous">

    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
    <![endif]-->

    <!-- Custom styles for this template -->
    <link href="../../css/canvas_srtate.css" rel="stylesheet">


    <script type="text/x-mathjax-config"> 
       MathJax.Hub.Config({ 
        "HTML-CSS": { scale: 94, linebreaks: { automatic: true } }
		});
    </script>

  </head>


  <body>

    <!-- Page Content -->
    <div class="container">
[ 
      <a target="_blank" href="https://www.uncg.edu/cmp/faculty/srtate/454.s20/assign5.html">View original, outside canvas</a> ]
   
        <p> </p>
<h2 id="assignment-5---due-april-29-2020">Assignment 5 - Due April 29, 2020</h2>
<ol type="1">
<li><p>The decision problem <span class="math inline">CLIQUE = {⟨<em>G</em>, <em>k</em>⟩ : <em>G</em></span> is a graph containing a clique of size <span class="math inline"><em>k</em>}</span> is defined on page 1087, along with a discussion of the clique problem. Show how to create a polynomial time algorithm to find the largest clique in a graph (in other words, output the actual subset of vertices in the largest clique) if <span class="math inline">CLIQUE ∈ <em>P</em></span>.</p></li>
<li><p>People who are interested in solving optimization problems would really like it if P=NP, with someone discovering an efficient algorithm for some NP-complete problem. All sorts of problems could be solved and optimized if this were this case! However, cryptographers really, really hope that P≠NP. Let’s see why.</p>
<p>First some brief background: Encryption takes a secret message <span class="math inline"><em>m</em></span> (called the plaintext) and an encryption key, and turns that into unintelligible data <span class="math inline"><em>c</em></span> (called the ciphertext). The receiver of the ciphertext uses a decryption function <span class="math inline"><em>D</em></span> along with decryption key <span class="math inline"><em>k</em></span> to recover the plaintext, so <span class="math inline"><em>D</em>(<em>k</em>, <em>c</em>) = <em>m</em></span>. In one style of attack, called a “known-plaintext attack,” the attacker knows a matching pair of plaintext/ciphertext values <span class="math inline">(<em>m</em>, <em>c</em>)</span>, and also knows the decryption algorithm <span class="math inline"><em>D</em></span>, but does not know the key that will decrypt <span class="math inline"><em>c</em></span> to <span class="math inline"><em>m</em></span>. The goal of the attacker is to compute <span class="math inline"><em>k</em></span> from this captured data, so that they can decrypt other captured ciphertext values for which they don’t know the secret plaintext.</p>
<p>For the rest of this problem, we are only looking at one decryption algorithm <span class="math inline"><em>D</em></span>, which can be computed in polynomial time, and both the key and the ciphertext inputs are <span class="math inline"><em>n</em></span>-bit binary strings. Note that in practice, <span class="math inline"><em>n</em></span> varies from 128 bits to 4096 bits, depending on the algorithm.</p>
<ol type="a">
<li><p>Consider decision problem <span class="math inline">KEY-PREFIX = {⟨<em>m</em>, <em>c</em>, <em>x</em>⟩ : <em>x</em></span> is a prefix of an <span class="math inline"><em>n</em></span>-bit string <span class="math inline"><em>k</em></span> such that <span class="math inline"><em>m</em> = <em>D</em>(<em>k</em>, <em>c</em>)}</span>. (<span class="math inline"><em>x</em></span> being a prefix of <span class="math inline"><em>k</em></span> means that if <span class="math inline"><em>k</em></span> is <span class="math inline"><em>n</em></span> bits long and <span class="math inline"><em>x</em></span> is <span class="math inline">|<em>x</em>| ≤ <em>n</em></span> bits long, then the first <span class="math inline">|<em>x</em>|</span> bits of <span class="math inline"><em>k</em></span> are <span class="math inline"><em>x</em></span>.) Prove that <span class="math inline">KEY-PREFIX ∈ <em>N</em><em>P</em></span>.</p></li>
<li><p>Prove that if <span class="math inline">KEY-PREFIX ∈ <em>P</em></span>, then there is a polynomial time algorithm that takes a matching plaintext/ciphertext pair <span class="math inline">(<em>m</em>, <em>c</em>)</span> and computes a key <span class="math inline"><em>k</em></span> such that <span class="math inline"><em>D</em>(<em>k</em>, <em>c</em>) = <em>m</em></span>.</p></li>
<li><p>Explain clearly what this means for the complexity of known-plaintext attacks if P=NP (your explanation should be general – think beyond this specific function <span class="math inline"><em>D</em></span> and to the general case of cryptography as a whole).</p></li>
<li><p>So that you’re not left with the impression that secure cryptography is impossible if P=NP, consider the following situation, which is compatible with the above arguments even if P=NP: Encrypting and decrypting operations take <span class="math inline">10 ⋅ <em>n</em><sup>2</sup></span> nanoseconds, testing <span class="math inline">KEY-PREFIX</span> takes <span class="math inline">100 ⋅ <em>n</em><sup>3</sup></span> nanoseconds, and so computing the key using this procedure takes <span class="math inline">100 ⋅ <em>n</em><sup>4</sup></span> nanoseconds. If <span class="math inline"><em>n</em> = 10, 000</span>, how long would it take to encrypt and decrypt? How long would it take to compute the key (to break the code)? If you had a particularly high-security application, you might consider using <span class="math inline"><em>n</em> = 100, 000</span>. Repeat your calculations for this value of <span class="math inline"><em>n</em></span>.</p></li>
</ol></li>
<li><p>Consider <span class="math inline">HALF-HAMILTONIAN = {⟨<em>G</em>⟩ : <em>G</em> = (<em>V</em>, <em>E</em>)</span> is an undirected graph with a simple cycle through <span class="math inline">|<em>V</em>|/2</span> vertices<span class="math inline">}</span>. Prove that <span class="math inline">HALF-HAMILTONIAN</span> is NP-complete.</p></li>
<li><p>While the minimum spanning tree problem has efficient algorithms, some other spanning tree problems are much harder. Recall the generic definition of a spanning tree: Given a connected graph <span class="math inline"><em>G</em> = (<em>V</em>, <em>E</em>)</span>, a spanning tree is a subset of edges <span class="math inline"><em>E</em>′ ⊆ <em>E</em></span> such that <span class="math inline"><em>G</em>′ = (<em>V</em>, <em>E</em>′)</span> is connected and acyclic. Define a a special type of spanning tree, a “<span class="math inline"><em>k</em></span>-spanner” (for <span class="math inline"><em>k</em> ≥ 2</span>) of a connected graph <span class="math inline"><em>G</em> = (<em>V</em>, <em>E</em>)</span>, as a spanning tree <span class="math inline"><em>E</em>′ ⊆ <em>E</em></span> such that every vertex in <span class="math inline"><em>G</em>′ = (<em>V</em>, <em>E</em>′)</span> has degree <span class="math inline"><em>k</em></span> or less.</p>
<ol type="a">
<li><p>All connected graphs have a spanning tree, but not all graphs have <span class="math inline"><em>k</em></span>-spanners for various values of <span class="math inline"><em>k</em></span>. Give an example of a connected graph that does not have a 3-spanner. (Hint: This is possible with 5 vertices.)</p></li>
<li><p>Define <span class="math inline">K-SPANNER = {⟨<em>G</em>, <em>k</em>⟩ : <em>G</em></span> is a connected graph and has a <span class="math inline"><em>k</em></span>-spanner<span class="math inline">}</span>. Prove that <span class="math inline">K-SPANNER</span> is NP-complete. (Hint: You may take as a “known NP-complete problem” any of the problems proved NP-complete in Section 34.5, <em>and</em> any of the ones mentioned as NP-complete in the exercises at the end of that section.)</p></li>
<li><p>This problem remains NP-complete for any fixed constant <span class="math inline"><em>k</em></span>. Define <span class="math inline">4-SPANNER = {⟨<em>G</em>⟩ : <em>G</em></span> is a connected graph and has a <span class="math inline">4</span>-spanner<span class="math inline">}</span>. Prove that <span class="math inline">4-SPANNER</span> is NP-complete. (Hint: If you’re clever, you can solve parts b and c together!)</p></li>
</ol></li>
</ol>
<p> </p>

    </div>

        <!-- jQuery CDN - Slim version (=without AJAX) -->
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <!-- Bootstrap JS -->
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.0/js/bootstrap.min.js" integrity="sha384-uefMccjFJAIv6A+rW+L4AHf99KvxDjWSu1z9VI8SKNVmz4sk7buKt/6v9KI65qnm" crossorigin="anonymous"></script>



  </body>

</html>
