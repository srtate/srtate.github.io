<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>CSC 580:  Cryptography and Security in Computing</title>
<link href="../css/classstyle.css" type="text/css" rel="stylesheet" />
</head>

<body>

<table border="0" cellpadding="0" cellspacing="0">
<tr><td width="800"><img src="580banner.jpg" alt="CSC 580: Cryptography and Security in Computing" /></td></tr>
</table>
<table border="0" cellpadding="0" cellspacing="0">
<col width="150" />
<col width="700" />
<tr><td valign="top">
<div class="navigate">
<div class="navhead">Navigation</div>
<div class="navother">
<a href="index.html">Class Home</a>
</div>
<div class="navother">
<a href="syllabus.html">Syllabus</a>
</div>
<div class="navother">
<a href="sched.html">Schedule</a>
</div>
<div class="navother">
<a href="readings.html">Readings</a>
</div>
<div class="navother">
<a href="handouts.html">Handouts</a>
</div>
<div class="navother">
Assignments
</div>
<div class="navother">
&nbsp;&nbsp;&bullet; <a href="homework.html">HW Problems</a>
</div>
<div class="navother">
&nbsp;&nbsp;&bullet; <a href="project.html">Project</a>
</div>
<div class="navother">
<a href="http://docs.oracle.com/javase/8/docs/technotes/guides/security/crypto/CryptoSpec.html">JCA Ref Guide</a>
</div>
<div class="navother">
<a href="http://docs.oracle.com/javase/8/docs/api/">Java API Docs</a>
</div>
<div class="navother">
<a href="http://canvas.uncg.edu/">Canvas</a>
</div>
<div class="navother">
<a href="moreinfo.html">More Information</a>
</div>
<img src="../img/navtail.png" alt="" />
</div>
</td><td valign="top"><div class="main">

<p>A <a href="projphase4.pdf">printable PDF</a> is available.</p>

<center><h1>Project Phase 4 -- Due Tuesday, April 25</h1></center>

<P><P><P><P>If you successfully completed phase 3 of the project, you should now
have a chat client that sends and receives messages that are secure
with respect to a passive adversary. In other words, the message
contents will remain secret from any adversary that doesn't actively
tamper with the communication. In this, the final phase, you will
incorporate integrity protections to ensure that you are chatting with
the right user and that messages are not tampered with. By completing
this phase, you will have a chat client that meets all of the
basic security requirements set out at the beginning of class,
although our interface does not have a way to send non-text messages
(this is a user-interface issue, however, not an issue with the
underlying chat system). The solution should protect against even a
malicious chat hub, and provides forward secrecy for conversations.
My solution for phase 3 will be available in BitBucket as soon as all
student submissions for phase 3 have been made, and you can start from
either my phase 3 solution or your own.
<OL><LI>For this part, you will <EM>generate a keypair and get a
  certificate that binds your public key to your username.</EM> Your chat
  program must utilize a "<CODE>KeyStore</CODE>" that stores both your own
  keypairs as well as certificates of known and trusted others. A
  keystore can be created and updated through the command-line tool
  "<CODE>keytool</CODE>," which is a standard part of the Java SDK. In the
  UNCG computer labs, all you need to do is open a command prompt and
  type "<CODE>keytool</CODE>" to run the program. Just running the program
  without any command-line arguments gives a list of commands that can
  be used, and documentation is at
  <A HREF="http://docs.oracle.com/javase/8/docs/technotes/tools/windows/keytool.html">http://docs.oracle.com/javase/8/docs/technotes/tools/windows/keytool.html</A>.
<P>  Keys stored in the keystore are accessed by an "alias," and for
  this program you should use the following naming convention: for
  keys that you own (so have both public and private keys), you should
  use the alias <CODE>mykey-username</CODE>, where <CODE>username</CODE> should be
  replaced by your UNCG username (e.g., user <CODE>joe</CODE> would store
  his key under alias <CODE>mykey-joe</CODE>). The keystore will be stored in
  a file that you choose and protected with a password that you
  select. The default values in the code I am providing use
  <CODE>chatapp.ks</CODE> as the keystore file and <CODE>defaultPW</CODE>
  for the password, but you can change these if you want. You need to
  be careful about what directory you store the keystore file in --
  if you don't use a full pathname and you are using NetBeans, it is
  easiest to store the file in the main NetBeans project
  directory. You should change into that directory before executing
  any of the <CODE>keytool</CODE> commands.
<P>  To generate your own keypair, use the <CODE>-genkeypair</CODE> command as
  shown below. Note that you must use your UNCG username as your chat
  system username, both in the alias name and in response to the first
  prompt asking for "first and last name" (despite the prompt, don't
  use your name here -- enter your username). The interaction, showing
  the creation of a keypair for user <CODE>joe</CODE> is shown below (only
  the "name" field is really used in the chat system, but use
  reasonable values for the other fields as shown below).
<P>  <TT>prompt$ <U>keytool -keystore chatapp.ks -genkeypair -alias mykey-joe</U><BR>Enter keystore password:  <BR>Re-enter new password: <BR>What is your first and last name?<BR>&nbsp; [Unknown]:  <u>joe</u><BR>What is the name of your organizational unit?<BR>&nbsp;  [Unknown]:  <u>CSC580</u><BR>What is the name of your organization?<BR>&nbsp;  [Unknown]:  <u>UNCG</u><BR>What is the name of your City or Locality?<BR>&nbsp;  [Unknown]:  <u>Greensboro</u><BR>What is the name of your State or Province?<BR>&nbsp;  [Unknown]:  <u>NC</u><BR>What is the two-letter country code for this unit?<BR>&nbsp;  [Unknown]:  <u>US</u><BR>Is CN=joe, OU=CSC580, O=UNCG, L=Greensboro, ST=NC, C=US correct?<BR>&nbsp;  [no]:  <u>yes</u><BR><BR>Enter key password for &lt;mykey-joe&gt;<BR>&nbsp;&nbsp;&nbsp; (RETURN if same as keystore password):  <BR></TT>
<P>Next, you will need to get a certificate from a trusted certification
authority (that's me!) for your key. To do this, extract a
"certificate request" from the keystore as shown below
<P><TT>keytool -keystore chatapp.ks -certreq -alias mykey-joe -rfc
  -file cert.req</TT>
<P>This creates a file named <CODE>cert.req</CODE> which you should email me as
an attachment from your UNCG email account. I will create the
certificate and email it back to you -- and only to your UNCG
account, and only if the request account matches the name in the
certificate request! The response will be a certificate, with a name
like <CODE>joe.crt</CODE> as well as the certification authority certificate
<CODE>ca.crt</CODE>. You will need to first install the CA certificate using
the <CODE>-importcert</CODE> command to <CODE>keytool</CODE>, and then you can
install your own certificate (use the same alias for your certificate
as you did when you generated the key). After you complete these
steps, your keystore will be ready to use by the chat program.
<LI>For this part, you will <EM>change the chat protocol so that
  the users exchange certificates and sign their <CODE>:ka1</CODE> public
  key exchange messages.</EM> To use the more secure protocols, you should
  connect to user "echatbot4", which differs from "echatbot3" in
  some important ways. First, "echatbot4" will provide two different
  ciphersuites on its "<CODE>:ka</CODE>" message:
  <CODE>ecdh-secp224r1+x509+aes128/cbc</CODE> (note that "nocert" from
  phase 3 changed to "x509") and
  <CODE>ecdh-secp224r1+x509+aes128/gcm128</CODE>. Until you get to part 5
  below, you should answer with
  <CODE>:kaok ecdh-secp224r1+x509+aes128/cbc</CODE> and just work on
  authenticating users (not messages).
<P>  This changes two things about the chat protocol:
  <UL><LI>The <CODE>:ka1</CODE> message should be immediately preceded by a
    "<CODE>:cert xxxx</CODE>" message, where <CODE>xxxx</CODE> is where your
    Base64-encoded certificate goes.
  <p><LI>The <CODE>:ka1</CODE> message now has two parts, each Base64 encoded
    and separated by spaces. The first part is simply the public key
    for the key agreement protocol, and the second part is a signature
    on the public key, made using the private key corresponding to the
    certificate that you shared in the preceding <CODE>:cert</CODE> message.
  </UL>
<p>The provided code includes a partially-implemented 
<CODE>ChatKeyManager</CODE> class, along with a new version of the
<CODE>LoginCredentials</CODE> class which allows it to keep track of the
<CODE>ChatKeyManager</CODE> to be used with any logged-in hub session. See
the code for details. The <CODE>ChatKeyManager</CODE> class 
includes the header for a method named <CODE>verifyCertAndSig</CODE>
that you will need to fill in. This method takes the name of the party
you are trying to communicate with, their certificate, the key
exchange data, and the signature, and returns either a <CODE>String</CODE>
describing an error or returns <CODE>null</CODE> if everything verifies
(right now it always returns <CODE>null</CODE>, so it accepts anything!).
In particular, you code should check that the certificate is signed by
the chat system Certification Authority, it is within the date range
for validity, and the common name ("CN") is the username of the
person you want to be chatting with. If that verifies, then the
signature on the key exchange data should also be verified.  If any of
these checks doesn't pass, your
<CODE>Conversation</CODE> class should send a <CODE>:fail</CODE> message with the
error description and then shut down the conversation. If all of the
checks are passed, then you can complete the key agreement protocol
and now you have established communication with a remote party whose
identity you have verified!
<LI>For this part, you will <EM>provide a means for the user to
  see the fingerprint of the remote party's certificate.</EM> The provided
  code adds a new menu item named "Other Party Info" to the GUI
  "Connection" menu, which is enabled only when there is an active
  connection. The action taken when this is enabled and selected by
  the user is to simply call <CODE>convo.getOtherInfo()</CODE> to get a
  String describing the other user. The resulting information window
  should look something like this:
  <BLOCKQUOTE><CENTER>
<img src="phase4infowindow.png" />
</CENTER></BLOCKQUOTE>
<P>  To maintain compatibility with <CODE>keytool</CODE>, the fingerprint
  is the SHA1 hash of the certificate.
<p><LI>For this part, you will <EM>use your keypair to log in to the
  chat hub.</EM> In the new version of the <CODE>LoginCredentials</CODE> class,
  there is a constructor that takes a <CODE>ChatKeyManager</CODE> object,
  but does not take a password string. If this constructor is used,
  then the system should use your keypair to log in as follows: The
  <CODE>LoginCredentials</CODE> method <EM>getUserID</EM> method now returns
  "pubkey username" instead of just "username," and when this is
  passed along to the chathub server it indicates that you want to use
  a public key authentication method to log in. The chat hub then
  sends a random string back as a challenge -- you should complete
  the code in the <CODE>LoginCredentials</CODE> class that will answer by
  prepending the string "login-" to the received challenge, signing
  that using your private key (corresponding to your certificate), and then sending both your certificate
  and the signature (both Base64 encoded, and separated by spaces)
  back as the answer to the challenge. If your certificate verifies as
  valid, the name in the certificate matches your claimed username,
  and the signature is valid, then you will be logged in.
<p><LI>For this part, you will <EM>add message integrity protection
  by using GCM mode for the symmetric cipher</EM>. Once you have all of
  the above parts working, you should change your <CODE>:kaok</CODE> message
  to select the <CODE>ecdh-secp224r1+x509+aes128/gcm128</CODE> ciphersuite, and
  switch the cipher to use GCM mode instead of CBC mode. This requires
  setting up parameters differently, using the <CODE>GCMParameterSpec</CODE>
  class, and catching <CODE>AEADBadTagException</CODE> to detect when the
  message integrity check fails. In <CODE>GCMParameterSpec</CODE>, you
  should use a "tag length" of 128 bits.  Information about how to
  use GCM mode
  is given in both the JCA documentation and in the <CODE>Cipher</CODE>
  class API documentation.
<p><LI><I>Extra Credit:</I> Extend the chat application so that it
  can save user certificates, and warn the user if a received
  certificate does not match the saved certificate. The details of how
  you do this is up to you. One possibility is to add a menu item to
  save the other party's certificate. After the certificate is saved,
  any subsequent connection to that user that provides a different
  certificate than the saved one you indicates a potential security
  issue, so you would give the user a warning (and possibly give an
  option to connect anyway).
</OL>


</div></td></tr>
</table>

</body> </html>

